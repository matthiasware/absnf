	template <typename T>
	void eval2(T *h_a, T *h_b, 
			  T *h_Z, T *h_L, 
			  T *h_J, T *h_Y,
			  T *h_dx,
			  int m, int n, int s,
			  T *h_dz, T *h_dy)
	{
		cublasHandle_t handle;
		cublasCreate(&handle);

		T *d_a; cudaMalloc((void **)&d_a, s*sizeof(T));
		T *d_Z; cudaMalloc((void **)&d_Z, s*n*sizeof(T)); // CM-STORAGE
		T *d_Z_rm; cudaMalloc((void **)&d_Z_rm, s*n*sizeof(T));
		T *d_Z_cm; cudaMalloc((void **)&d_Z_cm, s*n*sizeof(T));
		T *d_L; cudaMalloc((void **)&d_L, s*s*sizeof(T));
		T *d_dx; cudaMalloc((void **)&d_dx, n*sizeof(T));
		T *d_dz; cudaMalloc((void **)&d_dz, s*sizeof(T));
		
		cudaMemcpy(d_a, h_a,  s*sizeof(T), cudaMemcpyHostToDevice);
		cudaMemcpy(d_Z_rm, h_Z,  s*n*sizeof(T), cudaMemcpyHostToDevice);
		cudaMemcpy(d_Z, h_Z,  s*n*sizeof(T), cudaMemcpyHostToDevice);
		cudaMemcpy(d_L, h_L,  s*s*sizeof(T), cudaMemcpyHostToDevice);
		cudaMemcpy(d_dx, h_dx, n*sizeof(T), cudaMemcpyHostToDevice);
		
		double alpha = 1;
		double beta = 0; // saves init of dz
		// dz = Z * dx
		// dz = alpha * (Z * dx) + beta * dz
		cublasDgemv(handle, CUBLAS_OP_N, s, n, &alpha,
					d_Z, s, d_dx, 1, &beta, d_dz, 1);
	// WORKS UNTIL HERE
		// transpose Z
		cublasDgeam(handle,
			CUBLAS_OP_T,
			CUBLAS_OP_T,
			n, s,
			&alpha,
			d_Z,
			s,
			&beta,
			d_Z,
			s,
			d_Z_rm,
			n);
		// transpose Z
		cuutils::printf_vector(d_Z, s*n, "Z");
		cuutils::printf_vector(d_Z_rm, s*n, "Z_rm");
		// cuutils::printf_vector(d_dz, s, "dz");
		// int gridsize, blocksize;
		// cuutils::getGridBlockSize(&gridsize, &blocksize);
			// dz = dz + a
			// Does not scale:
			// cuutils::vvAdd <<<(s + BLOCKSIZE - 1) / BLOCKSIZE, BLOCKSIZE >>>(a, dz, dz, s);
		// cuutils::vvAdd <<<gridsize, blocksize >>>(a, dz, dz, s);

		
		cudaFree(d_a); 
		cudaFree(d_Z);
		cudaFree(d_L);
		cudaFree(d_dx);
		cudaFree(d_dz);
		

	// 	T *d_b; cudaMalloc((void **)&d_b, m*sizeof(T));
	// 	T *d_J; cudaMalloc((void **)&d_J, m*n*sizeof(T));
	// 	T *d_Y; cudaMalloc((void **)&d_Y, m*s*sizeof(T));		
	// 	T *d_dz; cudaMalloc((void **)&d_dz, s*sizeof(T));
	// 	T *d_abs_dz; cudaMalloc((void **)&d_abs_dz, s*sizeof(T));
	// 	T *d_dy; cudaMalloc((void **)&d_dy, m*sizeof(T));

	// 	cudaMemcpy(d_b, h_b,  m*sizeof(T), cudaMemcpyHostToDevice);
	// 	cudaMemcpy(d_J, h_J,  m*n*sizeof(T), cudaMemcpyHostToDevice);
	// 	cudaMemcpy(d_Y, h_Y,  m*s*sizeof(T), cudaMemcpyHostToDevice);

	// 	cublasHandle_t handle;
	// 	cublasCreate(&handle);
	// 	eval_core(handle, d_a, d_b,
	// 	 		  d_Z, d_L,
	// 	 		  d_J, d_Y,
	// 	 		  d_dx,
	// 	 		  m, n, s,
	// 	 		  d_dz, d_dy,
	// 	 		  d_abs_dz);
	// 	cudaMemcpy(h_dz, d_dz, s*sizeof(T), cudaMemcpyDeviceToHost);
	// 	cudaMemcpy(h_dy, d_dy, m*sizeof(T), cudaMemcpyDeviceToHost);

	// 	cudaFree(d_b);
	// 	cudaFree(d_J);
	// 	cudaFree(d_Y);
	// 	cudaFree(d_dz);
	// 	cudaFree(d_abs_dz);
	// 	cudaFree(d_dy);
	// 
	}