\section{Solve}
ABS-Normal Form:
\begin{flalign*}
	\begin{pmatrix}
		\Delta z \\
		\Delta y
	\end{pmatrix}
	= 
	\begin{pmatrix}
		a \\
		b
	\end{pmatrix}
	+
	\begin{pmatrix}
		Z & L \\
		J & Y 
	\end{pmatrix}
	\times
	\begin{pmatrix}
		\Delta x \\
		|\Delta z|
	\end{pmatrix}
\end{flalign*}

The last function, that had to be implemented was a solver for PL function in abs-normal form. Given:
\begin{flalign*}
	a,b,Z,L,J,Y,m,n,\Delta y
\end{flalign*}
We want to calculate:
\begin{flalign*}
	\Delta x, \Delta z
\end{flalign*}

\subsection{Deducing a solution}
In (paper). Multiple solutions with different propperties in convergence and efficiency have been suggested. Here we focus on the algorithm that in () is called modulus algorithm. \\
First and foremost, we assume:
\begin{flalign*}
	\Delta y = 0
\end{flalign*}
It this is not the case, we can replace $b$ with $b'$:
\begin{flalign*}
	b' = b - \Delta y
\end{flalign*}
Now we can shift the equation system:
\begin{flalign*}
	\Delta y &= b + J \Delta x + Y |\Delta z| \\
	0 &= b + J \Delta x + Y |\Delta z| \\
	- b - Y |\Delta z| &= J \Delta x \\
	b + Y |\Delta z| &= J \Delta x (-1) \\
	J^{-1}(b + Y |\Delta z|) &= - \Delta x
\end{flalign*}

\begin{flalign}
	\Delta x = - J^{-1}(b + Y |\Delta z|) \label{eq_modulus_dx}
\end{flalign}

\begin{flalign*}
	\Delta z &= a + Z \Delta x + L |\Delta z| \\
	&= a + Z \Big( - J^{-1}(b + Y |\Delta z|) \Big) +  L |\Delta z| \\
	&= a + Z \Big( -J^{-1}b - J^{-1}Y|\Delta z| \Big) +  L |\Delta z| \\
	&= a - ZJ^{-1}b - Z J^{-1}Y|\Delta z| +  L |\Delta z| \\
	&= a - ZJ^{-1}b - (Z J^{-1}Y - L)|\Delta z| \\
\end{flalign*}
and 
\begin{flalign}
\Delta z &= c + S|\Delta z| \label{eq_modulus} \\
c		 &= a - ZJ^{-1}b \label{eq_c} \\
S		 &= L - Z J^{-1}Y \label{eq_S}
\end{flalign}

We can use this result to construct a fix-point iteration algorithm where we recalculate $\Delta z$ in every step until convergence. Properties of this approach are given in (...). In the following we focus onto the implementation.
\begin{lstlisting}
...
\end{lstlisting}

\subsection{Implementation}
Implementing this algorithms means calculating \ref{eq_c} and \ref{eq_S} once and using these to repeatedly calculate \ref{eq_modulus}.
The key problem here is the calculation of $J^{-1}$, since this is the most expensive Operation. We decided to do a QR-decomposition of $J = QR$ and solving the linear equation system.
\begin{flalign*}
	J &= QR \\
	QR x &= b \\
	R x  &= Qb  
\end{flalign*}
\begin{flalign*}
	c = a - Zx
\end{flalign*}
The calculation of $S$ follows the same  pattern. After convergence $\Delta x$ can be calculated according to \ref{eq_modulus_dx}.

\begin{lstlisting}[caption={\label{lst_bg_size}}, language=cpp]
template <typename T>
void _global_ row_wise_traversal(T *matrix, int s)
{
int i = blockIdx.x;
int j = threadIdx.x;
int global_id = blockIdx.x * blockDim.x + threadIdx.x;
int id = i*s + j;
int size = s*s;
while(id < size && i < s)
{
matrix[id] = doSomething();
j += blockDim.x;
if (j>=s)
{
j = j % s;
i = i + gridDim.x;
}
id = i*s+j;
}
}
\end{lstlisting}